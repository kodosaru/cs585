
//opencv
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/imgproc/types_c.h>
#include <opencv2/imgproc/imgproc.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
//Boost
#define BOOST_FILESYSTEM_NO_DEPRECATED
#include "boost/filesystem/operations.hpp"
#include "boost/filesystem/path.hpp"
#include "boost/progress.hpp"
namespace fs = boost::filesystem;

using namespace cv;
using namespace std;

//global variables
int keyboard;

//function declarations
void processImages(char* pathForground, char* pathBackground, vector<string> backgroundFileNames, string pathOut);
unsigned long listFiles(String targetPath, vector<string>& fileNames);

int main(int argc, char* argv[])
{
    
    //check for the input parameter correctness
    if(argc != 2) {
        cerr <<"Incorrect input list" << endl;
        cerr <<"exiting..." << endl;
        return EXIT_FAILURE;
    }
    
    string pathOut="/Users/donj/workspace/cs585/Morphology/Data/Output/";
    char pathForeground[256],pathBackground[256];
    strcpy(pathForeground, "/Users/donj/workspace/cs585/Morphology/Data/Foreground/");
    strcat(pathForeground, argv[1]);

    Mat im = imread(pathForeground);
    Mat im_out;
    namedWindow("image1");
    namedWindow("image2");
    if (im.empty())
    {
        cout << "Cannot open image!" << endl;
        return -1;
    }
    //resize(im,im_out,Size(im.cols/3,im.rows/3),0,0,INTER_LINEAR);
    resize(im,im_out,Size(im.cols/3,im.rows/3));
    
    imshow("image1", im);
    imshow("image2", im_out);
    //waitKey(0);
    //return 0;
    
    //create GUI windows
    namedWindow("Foreground");
    namedWindow("FG Mask MOG");
    
    Mat in,out,final;
    in=imread(pathForeground);
    resize(in,final,Size((int)in.cols/3,(int)in.rows/3));
    imwrite(pathOut+"foregroundSmall.png",final);
    //imshow("Foreground", out);
    
    cvtColor(in,out,CV_BGR2XYZ);
    resize(out,final,Size(in.cols/3,in.rows/3));
    imwrite(pathOut+"foregroundCIE2.png",final);
    
    cvtColor(in,out,CV_BGR2YCrCb);
    resize(out,final,Size(in.cols/3.1,in.rows/3.1));
    imwrite(pathOut+"foregroundYCrCb.png",final);
    
    //keyboard = waitKey( 0 );
    return 0;
    
    
    
    // Create list of background images
    strcpy(pathBackground, "/Users/donj/workspace/cs585/Morphology/Data/Background/");
    vector<string> backgroundFileNames;
    cout << "File count: " << listFiles(pathBackground, backgroundFileNames) << endl;
    
    processImages(pathForeground,pathBackground,backgroundFileNames,pathOut);

    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

void processImages(char* pathForground, char* pathBackground, vector<string> backgroundFileNames, string pathOut) {

    Mat foregroundImage, backgroundImage;
    double learningRate=0.9;
    Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor

    Mat fgMaskMOG; //fg mask generated by MOG method

    // Create Background Subtractor objects
    int history=(int)backgroundFileNames.size()+1;
    int nmixtures=5;
    double backgroundRatio=0.9;
    double noiseSigma=0;
    unsigned char nShadowDetection = 127;
    
    //pMOG= new BackgroundSubtractorMOG(history, nmixtures, backgroundRatio, noiseSigma); //MOG approach

    int varThreshold=9;
    bool bShadowDetection=true;
    BackgroundSubtractorMOG2 bgr(history,varThreshold,bShadowDetection);
    
    //bgr.set("nmixtures", 100);
    //bgr.set("varThresholdGen", 9);
    //bgr.set("nShadowDetection", nShadowDetection);
    
    // Read in background images
    char path[256];
    for(int i=0;i<backgroundFileNames.size();i++)
    {
        strcpy(path,pathBackground);
        strcat(path,backgroundFileNames[i].c_str());
        backgroundImage=imread(path);
        //pMOG->operator()(backgroundImage,fgMaskMOG,learningRate);
        bgr.operator()(backgroundImage,fgMaskMOG,learningRate);
    }
    
    // Read in foreground image
    foregroundImage=imread(pathForground);
    //pMOG->operator()(foregroundImage,fgMaskMOG,learningRate);
    bgr.operator()(foregroundImage,fgMaskMOG,learningRate);

    // Show the foreground and foreground mask created from background images
    resize(foregroundImage,foregroundImage,Size(foregroundImage.cols/3,foregroundImage.rows/3));
    imshow("Foreground", foregroundImage);
    imwrite(pathOut+"foregroundImage.jpg", foregroundImage);
    resize(fgMaskMOG,fgMaskMOG,Size(fgMaskMOG.cols/3,fgMaskMOG.rows/3));
    imshow("FG Mask MOG", fgMaskMOG);
    imwrite(pathOut+"FG_Mask_MOG.jpg", fgMaskMOG);

    //get the input from the keyboard
    keyboard = waitKey( 0 );
}

unsigned long listFiles(String targetPath, vector<string>& fileNames)
{
    boost::progress_timer t( std::clog );
    
    fs::path full_path( fs::initial_path<fs::path>() );
    full_path = fs::system_complete( fs::path( targetPath ) );
    
    unsigned long file_count = 0;
    unsigned long dir_count = 0;
    unsigned long other_count = 0;
    unsigned long err_count = 0;
    
    if ( !fs::exists( full_path ) )
    {
        cout << "\nNot found: " << full_path.string() << std::endl;
        return 1;
    }
    
    if ( fs::is_directory( full_path ) )
    {
        cout << "\nIn directory: "
        << full_path.string() << "\n\n";
        fs::directory_iterator end_iter;
        for ( fs::directory_iterator dir_itr( full_path );
             dir_itr != end_iter;
             ++dir_itr )
        {
            try
            {
                if ( fs::is_directory( dir_itr->status() ) )
                {
                    ++dir_count;
                    std::cout << dir_itr->path().filename() << " [directory]\n";
                }
                else if ( fs::is_regular_file( dir_itr->status() ) )
                {
                    ++file_count;
                    std::cout << dir_itr->path().filename() << "\n";
                    fileNames.push_back(dir_itr->path().filename().string());
                }
                else
                {
                    ++other_count;
                    std::cout << dir_itr->path().filename() << " [other]\n";
                }
                
            }
            catch ( const std::exception & ex )
            {
                ++err_count;
                std::cout << dir_itr->path().filename() << " " << ex.what() << std::endl;
            }
        }
        std::cout << "\n" << file_count << " files\n"
        << dir_count << " directories\n"
        << other_count << " others\n"
        << err_count << " errors\n";
    }
    else // must be a file
    {
        ++file_count;
        std::cout << "\nFound: " << full_path.string() << "\n";
        fileNames.push_back(full_path.string());
    }
    return file_count;
}